# MiniVHDL to FIRRTL Compiler

## Overview

The **MiniVHDL to FIRRTL Compiler** is a tool designed to parse a simplified subset of VHDL (VHSIC Hardware Description Language) and generate FIRRTL (Flexible Intermediate Representation for RTL) code.

## Features

- Parses a subset of VHDL syntax.
- Supports entity, architecture, component, signal, and port declarations.
- Handles wire connections, instances, and operations.
- Resolves indexed wire assignments and converts them into FIRRTL-compatible expressions.
- Performs syntactic and semantic checks and provides error messages.
- Generates a valid FIRRTL representation of the input circuit.

The scanner and parser Java-sources are generated by using the [Coco/R compiler generator](https://ssw.jku.at/Research/Projects/Coco/). To do this it was necessary to define the 
whole MiniVHDL language including its semantic conditions and compiler-intern graph generation as an attributed grammar. This can be found in [CocoRGrammar.atg](./CocoRGrammar.atg).  

## Supported VHDL Subset

This MiniVHDL to FIRRTL compiler supports a simplified subset of VHDL syntax.

#### The exact grammar of the language is specified in [Grammar.txt](./Grammar.txt)!

Below is a description of the supported constructs, along with examples.

---

### **1. Entity**
The compiler supports the declaration of entities with `PORT` definitions, including input (`IN`) and output (`OUT`) ports. Ports can use `STD_ULOGIC` or `STD_ULOGIC_VECTOR` with indexing.

#### Example:
```vhdl
ENTITY add_sub IS
  PORT (
    a, b : IN STD_ULOGIC_VECTOR(7 DOWNTO 0);    -- 8-bit input vectors
    sub : IN STD_ULOGIC;                        -- Single-bit input
    result : OUT STD_ULOGIC_VECTOR(7 DOWNTO 0)  -- 8-bit output vector
  );
END;
```

---

### **2. Architecture with Components**
The compiler supports the declaration of architectures with components.
The component port order does not have to match the referred entity (re-ordering possible like in VHDL).

#### Example:
```vhdl
ARCHITECTURE structural OF add_sub IS
  COMPONENT adder
    PORT (
      a, b : IN STD_ULOGIC_VECTOR(7 DOWNTO 0);
      cin : IN STD_ULOGIC;
      cout : OUT STD_ULOGIC;
      sum : OUT STD_ULOGIC_VECTOR(7 DOWNTO 0)
    );
  END COMPONENT;

  SIGNAL bx : STD_ULOGIC_VECTOR(7 DOWNTO 0);        -- Intermediate signal
BEGIN
  bx <= b XOR (7 downto 0 => sub);                  -- Assignment with operator and indexing
  a0 : adder PORT MAP(a, bx, sub, OPEN, result);    -- Instantiation
END structural;
```

---

### **3. Instantiation**
The compiler allows instantiating components within architectures using the `PORT MAP` syntax. Ports can be connected directly to signals, ports, or `OPEN` for unused outputs.

#### Example:
```vhdl
a0 : adder PORT MAP(a, bx, sub, OPEN, result); -- Instantiation with 'OPEN' keyword for unused port
```

---

### **4. Assignment with Operators and Indexing**
Signal assignments support the use of logical operators (`AND`, `OR`, `XOR`, `NAND`, `NOR`, `XNOR`), the ability to specify individual bits or subranges using indexing (`DOWNTO`) or concatenate multiple expressions (`&`).

#### Example:
```vhdl
bx <= b XOR (7 downto 0 => sub);                   -- Apply XOR operation across all bits
o  <= a(9 downto 6) & a(5) & (2 downto 0 => a(4)); -- Example of concatinating and indexing
```

---

### **5. Immediates**
Immediate values can be assigned using the `"` or `'` quotes where the bits are set to a constant.

#### Example:
```vhdl
o1 <= "1"; -- Use immediate to set single bit
o2 <= "1010110"; -- Use immediate to set vector
```

---


### **Complete Example:**

One complete example including the FIRRTL output can be found in the Examples directory.

## Semantic Conditions
The following cases would be syntactically correct (given the defined [grammar](./Grammar.txt)) but are semantically incorrect.
Each case is handled by the compiler with an error message.
- All wires need to be driven.
- The name at the bottom of a declaration (entity / architecture / component) must match the name provided at the top.
- An entity referenced by an architecture must be declared before.
- An entity referenced by a component must be declared before.
- The overall number and names of a component ports must match the ports of its referenced entity (the order can change).
- A component referenced by an instantiation statement must be declared in the current architecture.
- At an assignment statement (<=) the two operands must be of equal width.
- At an assignment statement the left operand must be assignable to (no expressions using operands (like OR) and no immediate values).
- At an assignment statement the left operand must not be already driven.
- All ports and signals used in statements must exist in the current architecture or entity.
- When indexing (e.g. input(x downto y)) x has to be larger than y.
- When indexing (e.g. input(x) or input(x downto y)) x and y have to be inside the bounds of the vector.
- When using binary operators (like OR) the two operands must be of equal width (except when using the concat operator).
- At an aggregate expression (e.g. (7 downto 0 => flag)) the operand must be of length 1.
- The OPEN keyword can only be used for outputs.
- The port map of an instance must match the structure of the referenced component.
- Port mapping destinations of outputs must be assignable to (no expressions using operands (like OR) and no immediate values).
- At an immediate value only 1s and 0s are allowed.

## Usage



```bash
java -jar MiniVHDL.jar <input-file.vhdl> <top-level-entity>
```

### Parameters
- `<input-file.vhdl>`: The VHDL file to compile.
- `<top-level-entity>`: The name of the top-level entity for the FIRRTL file.

An entity with the same name as top-level-entity must exist.
### Output
The compiled FIRRTL code will be saved in the same directory as the input file with the filename `<top-level-entity>.fir`.
